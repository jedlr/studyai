Methods of making messages unintelligible to adversaries have been impor­ tant throughout history. In tliis chapter we shall cover some of the older cryptosystems that were primarily used before the advent of the computer. These cryptosystems are too weak to be of much use today, especially with computers at our disposal, but they give good illustrations of several of the important ideas of cryptology.
First, for these simple cryptosystems, we make some conventions.
• plaintext will be written in lowercase letters and CIPHERTEXT will be written in capital letters (except in the computer problems).
The letters of the alphabet are assigned numbers as follows:
abcdefghijk Imnop
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
qrstuvwxyz
16 17 18 19 20 21 22 23 24 25
Note that we start with a = 0, so z is letter number 25. Because many people are accustomed to a being 1 and z being 26, the present convention can be annoying, but it is standard for the elementary cryptosystems that we’ll consider.
Spaces and punctuation are omitted. This is even more annoying, but it is almost always possible to replace the spaces in the plaintext after decrypting. If spaces were left in, there would be two choices.
They could be left as spaces; but this yields so much information on the structure of the message that decryption becomes easier. Or they could be encrypted; but then they would dominate frequency counts (unless the message averages at least eight letters per word), again simplifying decryption.
Note: In this chapter, we'll be using some concepts from number theory, especially modular arithmetic. If you are not familiar with congruences, you should read the first three sections of Chapter 3 before proceeding.
2.1 Shift Ciphers
One of the earliest cryptosystems is often attributed to Julius Caesar. Sup­ pose he wanted to send a plaintext such as
gaul is divided into three parts
but he didn’t want Brutus to read it. He shifted each letter by three places, so a became D, b became E, c became F, etc. The end of the alphabet wrapped around to the beginning, so x became A, y became B, and z became C. The ciphertext was then
JDXOLVGLYLGHGLQWRWKUHHSDUWV.
Decryption was accomplished by shifting back by three spaces (and trying to figure out how to put the spaces back in).
We now give the general situation. If you are not familiar with modular arithmetic, read the first few pages of Chapter 3 before continuing.
Label the letters as integers from 0 to 25. The key is an integer k with 0 < k < 25. The encryption process is
x-> x+k  (mod26).
Decryption is x t-+ x —n (mod 26). For example, Caesar used k, = 3. Let’s see how the four types of attack work.
1. Ciphertext only: Eve has only the ciphertext. Her best strategy is an exhaustive search, since there are only 26 possible keys. If the message is longer than a few letters (we will make this more precise later when we discuss entropy), it is unlikely that there is more than one meaningful message that could be the plaintext. If you don’t believe this, try to find some words of four or five letters that are shifts of each other. One such is given in Exercise 1. Another possible attack, if the message is sufficiently long, is to do a frequency count for the various letters. The letter e occurs most frequently in most English texts. Suppose the letter L appears most frequently in the ciphertext. Since e = 4 and L = 11, a reasonable guess is that k = 11 —4 = 7. However, for shift ciphers this method takes much longer than an exhaustive search, plus it requires many more letters in the message in order for it to work (anything short, such as this, might not contain a common symbol, thus changing statistical counts).
2. Known plaintext: If you know just one letter of the plaintext along with the corresponding letter of ciphertext, you can deduce the key. For example, if you know t(= 19) encrypts to D(= 3), then the key is k=3-19= -16=10(mod26).
1, Chosen plaintext: Choose the letter a as the plaintext. The ciphertext gives the key. For example, if the ciphertext is H, then the key is 7.
<1. Chosen ciphertext: Choose the letter A as ciphertext. The plaintext is the negative of the key. For example, if the plaintext is h, the key Is-7= 19(mod2G).
2.2 Affine Ciphers
Tiio shift ciphers may be generalized and slightly strengthened as follows. Choose: two integers a and B, with gcd(a, 26) = 1, and consider the function (culled an affine function) x -> ax + B (mod 26).
For example, let a = 9 and 0 = 2, so we are working with 9x + 2. Take a plaintext letter such as h{= 7). It is encrypted to 9-7+ 2 = 65 = 13 (mod 2G), which is the letter N. Using the same function, we obtain
affine -> C V V W P M .
How do we decrypt? If we were working with rational numbers rather than mod 26, we would start with y = 9i + 2 and solve: x = =(y —2). But g needs to be reinterpreted when we work mod 26. Since gcd(9,26) = 1, there is n multiplicative inverse for 9 (mod 26) (if this last sentence doesn’t make sense to you, read Section 3.3 now). In fact, 9-3 = 1 (mod 26), so 3 is the desired inverse and can be used in place of We therefore have
x=3(y—2)=3y—6=3y+20 (mod26).
Let's try this. The letter V(= 21) is mapped to 3-21+20 = 83 = 5 (mod 26), which is the letter f. Similarly, we see that the ciphertext CVVWPM is decrypted back to affine.
Suppose we try to u s e the function 13x + 4 as our encryption function. We obtain
Input -> E R R E R .
If we alter the input, we obtain
alter -> ERRER.
Clearly this function leads to errors. It is impossible to decrypt, since several plaintexts yield the same ciphertext. In particular, we note that encryption must be one-to-one, and this fails in the present case.
What goes wrong in this example? If we solve y = 13x + 4, we obtain x = -£j(y —4). But does not exist mod 26 since gcd(13,26) = 13 # 1. More generally, it can be shown that ax + 0 is a one-to-one function mod 26 if and only if gcd(a, 26) = 1. In this case, decryption uses x = a'y —a'0 (mod 26), where act' = 1 (mod 26). So decryption is also accomplished by an affine function.
The key for this encryption method is the pair {a,B). There are 12 possible choices for a with gcd(a, 26) = 1 and there are 26 choices for B (since we are working mod 26, we only need to consider a and B between 0 and 25). Therefore, there are 12 x 26 = 312 choices for the key.
Let’s look at the possible attacks.
1. Ciphertext only: An exhaustive search through all 312 keys would take longer than the corresponding search in the case of the shift cipher; however, it would be very easy to do on a computer. When all possibilities for the key are tried, a fairly short ciphertext, say around 20 characters, will probably correspond to only one meaningful plaintext, thus allowing the determination of the key. It would also be possible to use frequency counts, though this would require much longer texts.
2. Known plaintext: With a little luck, knowing two letters of the plain­ text and the corresponding letters of the ciphertext suffices to find the key. In any case, the number of possibilities for the key is greatly reduced and a few more letters should yield the key.
For example, suppose the plaintext starts with if and the corresponding ciphertext is PQ. In numbers, this means that 8 (= i) maps to 15 (= P) and 5 maps to 16. Therefore, we have the equations
8a+B=15 and 5a+B= 16 (mod26).
Subtracting yields 3A = -1 = 25 (mod 26), which has the unique solution a= 17. Using the first equation, we find 8X17 + B = 15 (mod 26), which yields B = 9.
Suppose instead that the plaintext go corresponds to the ciphertext TH. We obtain the equations 6a+B=19 and 14a+B=7 (mod26).
Subtracting yields - 8a = 12 (mod 26). Since gcd(-8,26) = 2, this has two solutions: a = 5,18. The corresponding values of B are both 15 (this is not a coincidence; it will always happen this way when the coefficients of a in the equations are even). So we have two candidates for the key: (5,15) and (18,15). However, gcd(18, 26) ^ 1 so the second is ruled out. Therefore, the key is (5,15).
The preceding procedure works unless the gcd we get is 13 (or 26). In this case, use another letter of the message, if available.
If we know only one letter of plaintext, we still get a relation between a and B. For example, if we only know that g in plaintext corresponds to T in ciphertext, then we have 6a + B = 19 (mod 26). There are 12 possibilities for a and each gives one corresponding B. Therefore, an exhaustive search through the 12 keys should yield the correct key.
3. Chosen plaintext: Choose ab as the plaintext. The first character of the ciphertext will be ax0+ B = B1, and the second will be a + B. Therefore, we can find the key.
4. Chosen ciphertext: Choose AB as the ciphertext. This yields the decryption function of the form x = a1y + B1. We could solve for y and obtain the encryption key. But why bother? We have the decryption function, which is what we want.








